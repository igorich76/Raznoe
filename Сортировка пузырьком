a = [1, 7, -3, 9, 0, -67, 34, 12, 45, 1000, 6, 8, -2, 99]
длина_списка = len(a)

# внешний цикл мы делаем длиной длина_списка - 1 для того, чтобы алгоритм, оказавшись
# на последнем индексе списка не столкнулся с тем, что текущий элемент списка ему
# не с чем сравнивать, т.к. справа больше ничего нет

диапазон_внешнего_цикла = длина_списка - 1

for i in range(диапазон_внешнего_цикла):

# диапазон внутреннего списка мы уменьшаем на величину индекса текущего внешнего
# цикла потому, что в предыдущем цикле (если это не первый), мы уже поставили в
# конец списка самый большой элемент, а следовательно, сравнивать элементы списка,
# которые уже были отсортированы и стоят на своих местах, смысла нет.
# с каждым следующим внешним циклом, количество отсортированных и поставленных в
# конец списка элементов увеличивается на 1, как и увеличивается i. Следовательно,
# отнимая i от длины списка, мы выводим за границу обработки алгоритмом уже
# отсортированные элементы.

    диапазон_внутреннего_цикла = диапазон_внешнего_цикла - i
    
    for j in range(диапазон_внутреннего_цикла):
        
        if a[j] > a[j + 1]:                  # если порядок элементов пары неправильный
            a[j], a[j + 1] = a[j + 1], a[j]  # меняем элементы пары местами 

print('Отсортированный список:', a)
===================== ещё объяснение ======================================
вот тут с видео https://younglinux.info/algorithm/sort_min
# Заполняем список из 10 элементов
# случайными числами от 1 до 99 и
# выводим неотсортированный список на экран.
from random import randint
N = 10
arr = []
for i in range(N):
    arr.append(randint(1, 99))
print(arr)
 
 
# В цикле переменная i хранит индекс ячейки,
# в которую записывается минимальный элемент.
# Сначала это будет первая ячейка.
i = 0
 
# N - 1, так как последний элемент
# обменивать уже не надо.
while i < N - 1:
 
    # ПОИСК МИНИМУМА
    # Сначала надо найти минимальное значение
    # на срезе от i до конца списка.
    # Переменная m будет хранить индекс ячейки
    # с минимальным значением.
    # Сначала предполагаем, что
    # в ячейке i содержится минимальный элемент.
    m = i
    # Поиск начинаем с ячейки следующей за i.
    j = i + 1
    # Пока не дойдем до конца списка,
    while j < N:
        # будем сравнивать значение ячейки j,
        # со значением ячейки m.
        if arr[j] < arr[m]:
            # Если в j значение меньше, чем в m,
            # сохраним в m номер найденного
            # на данный момент минимума.
            m = j
        # Перейдем к следующей ячейке.
        j += 1
 
    # ОБМЕН ЗНАЧЕНИЙ
    # В ячейку i записывается найденный минимум,
    # а значение из ячейки i переносится
    # на старое место минимума.
    arr[i], arr[m] = arr[m], arr[i]
 
    # ПЕРЕХОД К СЛЕДУЮЩЕЙ НЕОБРАБОТАННОЙ ЯЧЕЙКЕ
    i += 1
 
 
# Вывод отсортированного списка
print(arr)
